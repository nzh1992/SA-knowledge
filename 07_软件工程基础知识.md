# 第7章 软件工程基础知识
本章设计单选、案例分析、论文，约占8~15分。
侧重于概念知识、管理知识。


#### 1. 软件危机（Software Crisis）
软件开发进度难以预测、开发成本难以控制、难以满足用户期望、质量无法保证、难以维护、缺少文档资料。


#### 2. 软件过程模型
为了使软件生命周期中各项任务能够有序地按照规程进行，需要一定的工作模型对各项任务予以规程约束，这样的模型被称为软件过程模型。


#### 3. 软件的生命周期
历经需求分析、设计、开发、运行维护、淘汰。


#### 4. 常见的软件过程模型
1. 瀑布模型（Waterfall Model）
是结构化开发使用的软件过程模型。特点是因果关系紧密相连，前一阶段工作的输出结果作为下一阶段工作的输入。
每个阶段完成后，都伴随着一个里程碑。
缺点是，需求难以一次搞定、变更的代价高、结果难以预见、各阶段无法并行。

过程依次是：
需求分析、系统设计、程序设计、编码实现、单元测试、集成测试、系统测试、运行维护

2. 原型模型（Prototype Model）
又称快速原型，解决了瀑布模型需求难以一次搞定、结果难以预见的缺点。
原型模型有两个阶段：原型开发、目标软件开发。
抛弃型原型，将原型作为需求确认的手段，在需求确认后就抛弃不用，继续用瀑布模型。
演化型原型，在需求确认结束后，不断补充和完善原型，直至形成一个完整的产品。

3. 螺旋模型（Spiral Model）
是在快速原型的基础上集合瀑布模型扩展而成。
把整个软件开发流程分为多个阶段，每一个阶段都由 目标设定、风险分析、开发和有效性验证、评审 组成。
支持大型软件开发，适用于面向规格说明、面向过程、面向对象的软件开发方法。
强调了其他模型忽视的风险分析。

4. 敏捷模型（Agile Model）
属于敏捷方法使用的模型，主要有 极限编程（Extreme Programming，EP）、水晶系列方法、并列争球法、特征驱动开发方法。

- 极限编程（XP）：高效、低风险、测试先行（先写测试代码、再编程）
- 水晶系列方法：不同的项目，采用不同的策略
- 并列争球法（Scrum）：该方法侧重于项目管理，用backlog管理需求，产品backlog是一个按照商业价值排序的需求列表。
根据backlog内容，将整个开发过程分为若干个短的迭代周期（Sprint），在Sprint中，Scrum团队从产品backlog中挑选最高优先级的需求组成Sprint Backlog。
在每个迭代结束时，Scrum团队将递交可交付的产品增量。所有Sprint结束时，交付最终的软件产品。
- 特征驱动开发方法（Feature Driven Development，FDD）：将开发人员分类，分为指挥者、类程序员等。


#### 5. 软件统一过程（Rational Unified Process，RUP）模型
RUP是一种重量级过程模型，属于结构化开发使用的软件过程模型。
其生命周期是一个二维模型，划分为多个循环（cycle），每个循环生成产品的一个新的版本，每个循环依次由初始、细化、构造、移交 4个连续阶段（phase）组成。


#### 6. RUP的9个核心工作流
- 业务建模
- 需求
- 分析与设计
- 实现
- 测试
- 部署
- 配置与变更管理
- 项目管理
- 环境


#### 7. RUP的特点
是用例驱动的、以架构为中心的、迭代和增量的软件开发过程。


#### 8. RUP的“4+1”视图模型
- 逻辑视图：对应最终用户，主要支持功能性需求，即在为用户提供服务方面系统所应该提供的功能。
逻辑视图常用类图、对象图、状态图、协作图表示。
- 实现视图：又称开发视图，对应程序员，关注软件开发环境下实际模块的组织，描述系统的各个部分如何被组织为模块和组件，
即开发环境中软件的静态组织结构。
该视图通常包含图和组件图。
- 进程视图：又叫过程视图，对应系统集成人员，考虑一些非功能性的需求，如性能和可用性，它可以解决并发性、分布性、系统完整性、容错性的问题。
进程视图常用活动图表示。
- 部署视图：又叫物理视图，对应系统工程师。描述如何将前面三个视图中所描述的系统设计实现为一组现实世界的实体。
展示了如何把软件映射到硬件上，它通常要考虑到系统性能、规模、可靠性等。
解决系统拓扑结构、系统安装、通信等问题。常用部署图表示。
- 用例视图：所有其他视图都依靠用例视图（场景）来指导他们，这就是被称为“4+1”模型的原因。


#### 9. 软件能力成熟度模型（Capability Maturity Model of Software，CMM）
CMM是一个概念模型，模型框架和表示是刚性的，不能随意改变，但模型的解释和实现由一定弹性。


#### 10. 软件能力成熟度模型集成（Capability Maturity Model Integration for Software，CMMI）
CMMI提供了一个软件能力成熟度的框架，它将软件改进过程的步骤组织成5个成熟度等级，初始级、已管理级、已定义级、量化管理级、优化级。
量化管理级 和 已定义级 的区别是，对过程性能的可预测。


#### 11. 软件需求的三个层次
- 业务需求（Bussiness Requirement）：反应了组织机构和客户对系统、产品的高层次的目标要求。
- 用户需求（User Requirement）：描述了用户使用产品必须要完成的任务，是用户对该软件的期望。
业务需求和软件需求构成了用户原始需求文档的内容。
- 功能需求（Functional Requirement）：从系统操作的角度定义了开发人员必须实现的软件功能，来满足业务需求和用户需求。


#### 12. 需求工程（Requirement Engineering，RE）
是指用已证实有效的原理、方法，通过合适的工具和记号，系统地描述开发系统及其行为特征和相关约束。


#### 13. 需求工程的五个阶段
- 需求获取
- 需求分析
- 形成需求规格（或 需求文档化）
- 需求确认与验证
- 需求管理


#### 14. 软件需求规格说明书（Software Requirement Specification，SRS）
具体包括功能需求、非功能需求、约束。
约束包括，设计约束、过程约束。
批准的SRS是需求开发和需求管理之间的桥梁。


#### 15. 需求管理
是一个对系统需求变更、了解、控制的过程，包括变更控制、版本控制、需求跟踪等功能。


#### 16. 需求获取
需求获取是获取系统的必要特征，或者是获得用户能接受的、系统必须满足的约束


#### 17. 需求获取的基本步骤
- 开发高层的业务模型
- 定义项目范围和高层需求
- 识别用户角色、用户代表
- 获取具体的需求
- 确定目标系统的业务工作流
- 需求整理和总结


#### 18. 需求变更
- 识别问题
- 问题分析和变更描述
- 变更分析和成本计算
- 变更实现
- 修改后的需求


#### 19. 变更控制委员会（Change Control Board，CCB）
由项目所涉及的多方成员共同组成，通常包括用户和实施方的决策人员。
CCB是决策机构，不是作业机构，通常CCB的工作是通过评审手段来决定项目是否能变更，但不提出变更方案。
过程及操作步骤为：制定决策、交流情况、重新协商约定。


#### 20. 需求跟踪
需求跟踪提供了由需求到产品实现整个过程范围的明确查询的能力。
需求跟踪的目的是，建立与维护“需求-设计-编程-测试”之间的一致性，确保所有的工作成果符合用户需求。


#### 21. 结构化方法（Structured Analysis and Structured Design，SASD）
又称为面向功能的软件开发方法 或 面向数据流的软件开发方法。
结构化分析（Structured Analysis，SA）：利用图形表达用户需求中的功能需求，使用的手段主要有数据流图（Data Flow Diagram，DFD）、
数据字典、结构化语言、判定表、判定树。
DFD的4种基本元素：数据流、处理/加工、数据存储、外部项。


#### 22. DFD必须满足的规则
- 父图数据流必须在子图中出现
- 一个处理，至少有一个输入流、一个输出流
- 一个存储，必定有流入和流出
- 一个数据流，至少有一端是处理端
- 模型表达的信息是全面的、完整的、正确的、一致的


#### 23. 数据字典（Data Dictionary）
是一种标记用户可以访问的数据项和元数据的目录，是对系统中使用的所有数据元素定义的集合，包括数据项、数据结构、数据流、数据存储、处理过程。


#### 24. 结构化设计（Structured Design，SD）
是一种面向数据流的设计方法，以SRS和SA阶段所产生的数据流图、数据字典等文档为基础，是一个自顶向下、逐步求精、模块化的过程。
分为概要设计、详细设计两个阶段。
概要设计的主要任务是，确定系统的结构、对系统进行模块划分，确定每个模块的功能、接口、模块之间的调用关系。
详细设计的主要任务是，每个模块设计实现的细节。


#### 25. 在SD中模块是实现的基本单位，一般具有功能、逻辑、状态，3个基本属性。


#### 26. 模块的耦合类型（从低到高）
- 非直接耦合：两个模块之间没有直接关系，互相不依赖对方
- 数据耦合：一组模块借助参数表传递简单数据
- 标记耦合：一组模块通过参数表传递记录等复杂信息（数据结构）
- 控制耦合：模块之间传递的信息中，包含用于直接控制模块内部的逻辑信息
- 通信耦合：一组模块共享了输入或输出
- 公共耦合：多个模块都访问同一个公共数据环境，公共的数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区
- 内容耦合：一个模块直接访问另一个模块的内部数据、一个模块不通过正常入口跳转到另一个模块的内部、两个模块都有一部分程序代码重叠、一个模块有个入口等


#### 27. 内聚的类型（从高到低）
- 功能内聚：各个部分协同完成一个单一功能，缺一不可
- 顺序内聚：处理元素相关，而且必须顺序执行，通常前一个任务的输出是后一个任务的输入
- 通信内聚：所有处理元素集中在一个数据结构的区域上
- 过程内聚：处理元素相关，且必须按照特定的次序执行
- 时间内聚：所有包含的任务必须在同一时间间隔内执行
- 逻辑内聚：完成逻辑上相关的一组任务，互相存在调用关系
- 偶然内聚：完成一组没有关系 或 松散关系的任务，或仅仅是代码相似


#### 28. 面向对象的分析方法（Object-Oriented Analysis，OOA）
由5个层次和5个活动组成。
层次分别是，主题层、对象类层、结构层、属性层、服务层。
活动分别是，标识对象类、标识结构、定义主题、定义属性、定义服务。


#### 29. OOA的基本原则
抽象、封装、继承、分类、聚合、关联、消息通信、粒度控制、行为分析。


#### 30. OOA的5个基本步骤
确定对象和类、确定结构、确定主题、确定属性、确定方法


#### 31. 面相对象设计方法（Object-Oriented Design，OOD）
类封装了信息和行为，是具有相同属性、方法、关系的对象集合总成。


#### 32. 类的三种类型
- 实体类：通常都是永久性需要储存的。
- 控制类：用于控制用例工作的类，控制对象通常控制其他对象或调用其他对象的行为，例如登录验证。
- 边界类：用于封装在用例内外流动的信息或数据流，例如窗口、通信协议、接口等。


#### 33. 面向对象程序设计（Object-Oriented Programming，OOP）
OOP以对象为核心，该方法认为程序由一系列对象组成。


#### 34. 逆向工程（Reverse Engineering）
通过分析已有程序，寻求比源码更高级的抽象表现形式（文档）的活动，实在不同抽象层级进行溯源的行为。


#### 35. 软件测试的目的
测试是确保软件的质量，确认软件以正确的方式做了用户所期望的事情。


#### 36. 测试分类
###### 根据程序的执行状态
静态测试（Static Testing）、动态测试（Dynamic Testing）
###### 根据是否关注实现和内部结构
黑盒测试、白盒测试、灰盒测试
###### 根据执行方式
人工测试（Manual Testing）、自动化测试（Automatic Testing）
###### 从阶段上划分
单元测试、集成测试、系统测试、验收测试








